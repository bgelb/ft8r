name: CI

# Run on all pushes and pull requests. Limiting to main can
# accidentally skip runs for non-main PR targets.
on: [push, pull_request]

# Allow posting a PR comment while keeping other scopes minimal.
permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: requirements.txt

      - name: Ensure required system tools
        run: |
          sudo apt-get update
          sudo apt-get install -y rsync unzip jq

      - name: Run setup and tests (verbose)
        env:
          FT8R_WHITEN_ENABLE: '1'
          FT8R_COARSE_MODE: budget
          FT8R_MAX_CANDIDATES: '1500'
          FT8R_MIN_LLR_AVG: '0.0'
          FT8R_DEBUG_WHITEN: '1'
          FT8R_DEBUG_COARSE: '1'
        run: |
          bash scripts/setup_env.sh --test

      - name: Debug FT8R environment snapshot
        if: always()
        run: |
          set -euo pipefail
          echo "FT8R_* environment variables:" || true
          env | sort | grep '^FT8R_' || true
          echo "\nPython-side whitening detection:" || true
          python - <<'PY'
          import os
          flag = os.getenv('FT8R_WHITEN_ENABLE')
          enabled = (flag is None) or (flag not in ('0','false','False'))
          print('FT8R_WHITEN_ENABLE raw =', repr(flag))
          print('whitening_enabled (computed) =', enabled)
          PY
          echo "\nPython/numpy/scipy versions:" || true
          python - <<'PY'
          import platform, sys
          print('platform:', platform.platform())
          print('python:', sys.version)
          try:
              import numpy as np
              print('numpy:', np.__version__)
          except Exception as e:
              print('numpy: ERROR', e)
          try:
              import scipy
              print('scipy:', scipy.__version__)
          except Exception as e:
              print('scipy: ERROR', e)
          PY

      - name: Read short regression metrics
        if: always()
        id: metrics_short
        run: |
          set -euo pipefail
          FILE=".tmp/ft8r_short_metrics.json"
          if [[ -f "$FILE" ]]; then
            total_decodes=$(jq -r '.total_decodes' "$FILE")
            correct_decodes=$(jq -r '.correct_decodes' "$FILE")
            false_decodes=$(jq -r '.false_decodes' "$FILE")
            total_signals=$(jq -r '.total_signals' "$FILE")
            decode_rate=$(jq -r '.decode_rate' "$FILE")
            false_decode_rate=$(jq -r '.false_decode_rate' "$FILE")
          else
            echo "Metrics file not found at $FILE"
            total_decodes=; correct_decodes=; false_decodes=; total_signals=; decode_rate=; false_decode_rate=
          fi
          echo "total_decodes=$total_decodes" >> "$GITHUB_OUTPUT"
          echo "correct_decodes=$correct_decodes" >> "$GITHUB_OUTPUT"
          echo "false_decodes=$false_decodes" >> "$GITHUB_OUTPUT"
          echo "total_signals=$total_signals" >> "$GITHUB_OUTPUT"
          echo "decode_rate=$decode_rate" >> "$GITHUB_OUTPUT"
          echo "false_decode_rate=$false_decode_rate" >> "$GITHUB_OUTPUT"
          if [[ -f "$FILE" ]]; then
            duration_sec=$(jq -r '.duration_sec' "$FILE")
            echo "duration_sec=$duration_sec" >> "$GITHUB_OUTPUT"
            num_files=$(jq -r '.num_files' "$FILE")
            avg_runtime=$(jq -r '.avg_runtime_per_file_sec' "$FILE")
            echo "num_files=$num_files" >> "$GITHUB_OUTPUT"
            echo "avg_runtime=$avg_runtime" >> "$GITHUB_OUTPUT"
          fi

      - name: Read full regression metrics
        if: always()
        id: metrics_full
        run: |
          set -euo pipefail
          FILE=".tmp/ft8r_full_metrics.json"
          if [[ -f "$FILE" ]]; then
            total_decodes=$(jq -r '.total_decodes' "$FILE")
            correct_decodes=$(jq -r '.correct_decodes' "$FILE")
            false_decodes=$(jq -r '.false_decodes' "$FILE")
            total_signals=$(jq -r '.total_signals' "$FILE")
            decode_rate=$(jq -r '.decode_rate' "$FILE")
            false_decode_rate=$(jq -r '.false_decode_rate' "$FILE")
          else
            total_decodes=; correct_decodes=; false_decodes=; total_signals=; decode_rate=; false_decode_rate=
          fi
          echo "total_decodes=$total_decodes" >> "$GITHUB_OUTPUT"
          echo "correct_decodes=$correct_decodes" >> "$GITHUB_OUTPUT"
          echo "false_decodes=$false_decodes" >> "$GITHUB_OUTPUT"
          echo "total_signals=$total_signals" >> "$GITHUB_OUTPUT"
          echo "decode_rate=$decode_rate" >> "$GITHUB_OUTPUT"
          echo "false_decode_rate=$false_decode_rate" >> "$GITHUB_OUTPUT"
          if [[ -f "$FILE" ]]; then
            duration_sec=$(jq -r '.duration_sec' "$FILE")
            echo "duration_sec=$duration_sec" >> "$GITHUB_OUTPUT"
            num_files=$(jq -r '.num_files' "$FILE")
            avg_runtime=$(jq -r '.avg_runtime_per_file_sec' "$FILE")
            echo "num_files=$num_files" >> "$GITHUB_OUTPUT"
            echo "avg_runtime=$avg_runtime" >> "$GITHUB_OUTPUT"
          fi

      - name: Comment decode metrics on PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          SHORT_TOTAL_DECODES: ${{ steps.metrics_short.outputs.total_decodes }}
          SHORT_CORRECT_DECODES: ${{ steps.metrics_short.outputs.correct_decodes }}
          SHORT_FALSE_DECODES: ${{ steps.metrics_short.outputs.false_decodes }}
          SHORT_TOTAL_SIGNALS: ${{ steps.metrics_short.outputs.total_signals }}
          SHORT_DECODE_RATE: ${{ steps.metrics_short.outputs.decode_rate }}
          SHORT_FALSE_DECODE_RATE: ${{ steps.metrics_short.outputs.false_decode_rate }}
          SHORT_DURATION_SEC: ${{ steps.metrics_short.outputs.duration_sec }}
          SHORT_NUM_FILES: ${{ steps.metrics_short.outputs.num_files }}
          SHORT_AVG_RUNTIME: ${{ steps.metrics_short.outputs.avg_runtime }}
          FULL_TOTAL_DECODES: ${{ steps.metrics_full.outputs.total_decodes }}
          FULL_CORRECT_DECODES: ${{ steps.metrics_full.outputs.correct_decodes }}
          FULL_FALSE_DECODES: ${{ steps.metrics_full.outputs.false_decodes }}
          FULL_TOTAL_SIGNALS: ${{ steps.metrics_full.outputs.total_signals }}
          FULL_DECODE_RATE: ${{ steps.metrics_full.outputs.decode_rate }}
          FULL_FALSE_DECODE_RATE: ${{ steps.metrics_full.outputs.false_decode_rate }}
          FULL_DURATION_SEC: ${{ steps.metrics_full.outputs.duration_sec }}
          FULL_NUM_FILES: ${{ steps.metrics_full.outputs.num_files }}
          FULL_AVG_RUNTIME: ${{ steps.metrics_full.outputs.avg_runtime }}
        with:
          script: |
            const marker = '<!-- ft8r-metrics -->';
            function fmtSection(title, env) {
              const td = env.TOTAL_DECODES;
              const cd = env.CORRECT_DECODES;
              const fd = env.FALSE_DECODES;
              const ts = env.TOTAL_SIGNALS;
              const dr = env.DECODE_RATE;
              const fdr = env.FALSE_DECODE_RATE;
              const dur = env.DURATION_SEC;
              const nf = env.NUM_FILES;
              const avg = env.AVG_RUNTIME;
              if (!td || !cd || !fd || !ts || !dr || !fdr) {
                return `**${title}**\n- NOT RUN`;
              }
              const tdi = parseInt(td,10);
              const cdi = parseInt(cd,10);
              const fdi = parseInt(fd,10);
              const tsi = parseInt(ts,10);
              const drp = (parseFloat(dr)*100).toFixed(1);
              const fdrp = (parseFloat(fdr)*100).toFixed(2);
              const durS = dur ? `${parseFloat(dur).toFixed(1)}s` : 'N/A';
              const nfi = nf ? parseInt(nf,10) : NaN;
              let avgS = 'N/A';
              if (avg) {
                avgS = `${parseFloat(avg).toFixed(2)}s`;
              } else if (dur && nf) {
                const val = parseFloat(dur) / parseInt(nf,10);
                if (isFinite(val)) avgS = `${val.toFixed(2)}s`;
              }
              return `**${title}**
              - total decodes: ${tdi}
              - correct decodes: ${cdi}
              - false decodes: ${fdi}
              - total signals: ${tsi}
              - total samples: ${isNaN(nfi) ? 'N/A' : nfi}
              - decode rate: ${drp}%
              - false decode rate: ${fdrp}%
              - runtime: ${durS}
              - avg runtime per 15s WAV: ${avgS}`;
            }
            const shortEnv = {
              TOTAL_DECODES: process.env.SHORT_TOTAL_DECODES,
              CORRECT_DECODES: process.env.SHORT_CORRECT_DECODES,
              FALSE_DECODES: process.env.SHORT_FALSE_DECODES,
              TOTAL_SIGNALS: process.env.SHORT_TOTAL_SIGNALS,
              DECODE_RATE: process.env.SHORT_DECODE_RATE,
              FALSE_DECODE_RATE: process.env.SHORT_FALSE_DECODE_RATE,
              DURATION_SEC: process.env.SHORT_DURATION_SEC,
              NUM_FILES: process.env.SHORT_NUM_FILES,
              AVG_RUNTIME: process.env.SHORT_AVG_RUNTIME,
            };
            const fullEnv = {
              TOTAL_DECODES: process.env.FULL_TOTAL_DECODES,
              CORRECT_DECODES: process.env.FULL_CORRECT_DECODES,
              FALSE_DECODES: process.env.FULL_FALSE_DECODES,
              TOTAL_SIGNALS: process.env.FULL_TOTAL_SIGNALS,
              DECODE_RATE: process.env.FULL_DECODE_RATE,
              FALSE_DECODE_RATE: process.env.FULL_FALSE_DECODE_RATE,
              DURATION_SEC: process.env.FULL_DURATION_SEC,
              NUM_FILES: process.env.FULL_NUM_FILES,
              AVG_RUNTIME: process.env.FULL_AVG_RUNTIME,
            };
            const body = [
              marker,
              fmtSection('Short Sample WAVs', shortEnv),
              '',
              fmtSection('Full Sample WAVs', fullEnv),
            ].join('\n');
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const prev = comments.find(c => c.body && c.body.includes(marker));
            if (prev) {
              await github.rest.issues.updateComment({owner, repo, comment_id: prev.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number, body});
            }

      - name: Run performance summary
        if: always()
        run: |
          python --version
          PYTHONPATH="$GITHUB_WORKSPACE" python scripts/perf_summary.py \
            --stem ${FT8R_PERF_STEM:-websdr_test6} \
            --repeats ${FT8R_PERF_REPEATS:-3} | tee .tmp/ft8r_perf.json

      - name: Comment performance on PR
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          PERF_JSON: .tmp/ft8r_perf.json
        with:
          script: |
            const marker = '<!-- ft8r-perf -->';
            const fs = require('fs');
            let body;
            try {
              const txt = fs.readFileSync(process.env.PERF_JSON, 'utf8');
              const j = JSON.parse(txt);
              const best = (j.best_s ?? 0).toFixed(3);
              const avg = (j.avg_s ?? 0).toFixed(3);
              const med = (j.median_s ?? 0).toFixed(3);
              const dec = j.decoded_count ?? 0;
              body = `${marker}\n**Performance (decode_full_period)**\n- sample: ${j.stem}\n- repeats: ${j.repeats}\n- best: ${best}s\n- avg: ${avg}s (median: ${med}s)\n- decoded count (last run): ${dec}`;
            } catch (e) {
              body = `${marker}\n**Performance (decode_full_period)**\n- NOT RUN`;
            }
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const prev = comments.find(c => c.body && c.body.includes(marker));
            if (prev) {
              await github.rest.issues.updateComment({owner, repo, comment_id: prev.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number, body});
            }
